{"ast":null,"code":"/*!\n * Isotope v3.0.6\n *\n * Licensed GPLv3 for open source use\n * or Isotope Commercial License for commercial use\n *\n * https://isotope.metafizzy.co\n * Copyright 2010-2018 Metafizzy\n */\n\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['outlayer/outlayer', 'get-size/get-size', 'desandro-matches-selector/matches-selector', 'fizzy-ui-utils/utils', './item', './layout-mode',\n    // include default layout modes\n    './layout-modes/masonry', './layout-modes/fit-rows', './layout-modes/vertical'], function (Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {\n      return factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('outlayer'), require('get-size'), require('desandro-matches-selector'), require('fizzy-ui-utils'), require('./item'), require('./layout-mode'),\n    // include default layout modes\n    require('./layout-modes/masonry'), require('./layout-modes/fit-rows'), require('./layout-modes/vertical'));\n  } else {\n    // browser global\n    window.Isotope = factory(window, window.Outlayer, window.getSize, window.matchesSelector, window.fizzyUIUtils, window.Isotope.Item, window.Isotope.LayoutMode);\n  }\n})(window, function factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {\n  'use strict';\n\n  // -------------------------- vars -------------------------- //\n  var jQuery = window.jQuery;\n\n  // -------------------------- helpers -------------------------- //\n\n  var trim = String.prototype.trim ? function (str) {\n    return str.trim();\n  } : function (str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  };\n\n  // -------------------------- isotopeDefinition -------------------------- //\n\n  // create an Outlayer layout class\n  var Isotope = Outlayer.create('isotope', {\n    layoutMode: 'masonry',\n    isJQueryFiltering: true,\n    sortAscending: true\n  });\n  Isotope.Item = Item;\n  Isotope.LayoutMode = LayoutMode;\n  var proto = Isotope.prototype;\n  proto._create = function () {\n    this.itemGUID = 0;\n    // functions that sort items\n    this._sorters = {};\n    this._getSorters();\n    // call super\n    Outlayer.prototype._create.call(this);\n\n    // create layout modes\n    this.modes = {};\n    // start filteredItems with all items\n    this.filteredItems = this.items;\n    // keep of track of sortBys\n    this.sortHistory = ['original-order'];\n    // create from registered layout modes\n    for (var name in LayoutMode.modes) {\n      this._initLayoutMode(name);\n    }\n  };\n  proto.reloadItems = function () {\n    // reset item ID counter\n    this.itemGUID = 0;\n    // call super\n    Outlayer.prototype.reloadItems.call(this);\n  };\n  proto._itemize = function () {\n    var items = Outlayer.prototype._itemize.apply(this, arguments);\n    // assign ID for original-order\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      item.id = this.itemGUID++;\n    }\n    this._updateItemsSortData(items);\n    return items;\n  };\n\n  // -------------------------- layout -------------------------- //\n\n  proto._initLayoutMode = function (name) {\n    var Mode = LayoutMode.modes[name];\n    // set mode options\n    // HACK extend initial options, back-fill in default options\n    var initialOpts = this.options[name] || {};\n    this.options[name] = Mode.options ? utils.extend(Mode.options, initialOpts) : initialOpts;\n    // init layout mode instance\n    this.modes[name] = new Mode(this);\n  };\n  proto.layout = function () {\n    // if first time doing layout, do all magic\n    if (!this._isLayoutInited && this._getOption('initLayout')) {\n      this.arrange();\n      return;\n    }\n    this._layout();\n  };\n\n  // private method to be used in layout() & magic()\n  proto._layout = function () {\n    // don't animate first layout\n    var isInstant = this._getIsInstant();\n    // layout flow\n    this._resetLayout();\n    this._manageStamps();\n    this.layoutItems(this.filteredItems, isInstant);\n\n    // flag for initalized\n    this._isLayoutInited = true;\n  };\n\n  // filter + sort + layout\n  proto.arrange = function (opts) {\n    // set any options pass\n    this.option(opts);\n    this._getIsInstant();\n    // filter, sort, and layout\n\n    // filter\n    var filtered = this._filter(this.items);\n    this.filteredItems = filtered.matches;\n    this._bindArrangeComplete();\n    if (this._isInstant) {\n      this._noTransition(this._hideReveal, [filtered]);\n    } else {\n      this._hideReveal(filtered);\n    }\n    this._sort();\n    this._layout();\n  };\n  // alias to _init for main plugin method\n  proto._init = proto.arrange;\n  proto._hideReveal = function (filtered) {\n    this.reveal(filtered.needReveal);\n    this.hide(filtered.needHide);\n  };\n\n  // HACK\n  // Don't animate/transition first layout\n  // Or don't animate/transition other layouts\n  proto._getIsInstant = function () {\n    var isLayoutInstant = this._getOption('layoutInstant');\n    var isInstant = isLayoutInstant !== undefined ? isLayoutInstant : !this._isLayoutInited;\n    this._isInstant = isInstant;\n    return isInstant;\n  };\n\n  // listen for layoutComplete, hideComplete and revealComplete\n  // to trigger arrangeComplete\n  proto._bindArrangeComplete = function () {\n    // listen for 3 events to trigger arrangeComplete\n    var isLayoutComplete, isHideComplete, isRevealComplete;\n    var _this = this;\n    function arrangeParallelCallback() {\n      if (isLayoutComplete && isHideComplete && isRevealComplete) {\n        _this.dispatchEvent('arrangeComplete', null, [_this.filteredItems]);\n      }\n    }\n    this.once('layoutComplete', function () {\n      isLayoutComplete = true;\n      arrangeParallelCallback();\n    });\n    this.once('hideComplete', function () {\n      isHideComplete = true;\n      arrangeParallelCallback();\n    });\n    this.once('revealComplete', function () {\n      isRevealComplete = true;\n      arrangeParallelCallback();\n    });\n  };\n\n  // -------------------------- filter -------------------------- //\n\n  proto._filter = function (items) {\n    var filter = this.options.filter;\n    filter = filter || '*';\n    var matches = [];\n    var hiddenMatched = [];\n    var visibleUnmatched = [];\n    var test = this._getFilterTest(filter);\n\n    // test each item\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item.isIgnored) {\n        continue;\n      }\n      // add item to either matched or unmatched group\n      var isMatched = test(item);\n      // item.isFilterMatched = isMatched;\n      // add to matches if its a match\n      if (isMatched) {\n        matches.push(item);\n      }\n      // add to additional group if item needs to be hidden or revealed\n      if (isMatched && item.isHidden) {\n        hiddenMatched.push(item);\n      } else if (!isMatched && !item.isHidden) {\n        visibleUnmatched.push(item);\n      }\n    }\n\n    // return collections of items to be manipulated\n    return {\n      matches: matches,\n      needReveal: hiddenMatched,\n      needHide: visibleUnmatched\n    };\n  };\n\n  // get a jQuery, function, or a matchesSelector test given the filter\n  proto._getFilterTest = function (filter) {\n    if (jQuery && this.options.isJQueryFiltering) {\n      // use jQuery\n      return function (item) {\n        return jQuery(item.element).is(filter);\n      };\n    }\n    if (typeof filter == 'function') {\n      // use filter as function\n      return function (item) {\n        return filter(item.element);\n      };\n    }\n    // default, use filter as selector string\n    return function (item) {\n      return matchesSelector(item.element, filter);\n    };\n  };\n\n  // -------------------------- sorting -------------------------- //\n\n  /**\n   * @params {Array} elems\n   * @public\n   */\n  proto.updateSortData = function (elems) {\n    // get items\n    var items;\n    if (elems) {\n      elems = utils.makeArray(elems);\n      items = this.getItems(elems);\n    } else {\n      // update all items if no elems provided\n      items = this.items;\n    }\n    this._getSorters();\n    this._updateItemsSortData(items);\n  };\n  proto._getSorters = function () {\n    var getSortData = this.options.getSortData;\n    for (var key in getSortData) {\n      var sorter = getSortData[key];\n      this._sorters[key] = mungeSorter(sorter);\n    }\n  };\n\n  /**\n   * @params {Array} items - of Isotope.Items\n   * @private\n   */\n  proto._updateItemsSortData = function (items) {\n    // do not update if no items\n    var len = items && items.length;\n    for (var i = 0; len && i < len; i++) {\n      var item = items[i];\n      item.updateSortData();\n    }\n  };\n\n  // ----- munge sorter ----- //\n\n  // encapsulate this, as we just need mungeSorter\n  // other functions in here are just for munging\n  var mungeSorter = function () {\n    // add a magic layer to sorters for convienent shorthands\n    // `.foo-bar` will use the text of .foo-bar querySelector\n    // `[foo-bar]` will use attribute\n    // you can also add parser\n    // `.foo-bar parseInt` will parse that as a number\n    function mungeSorter(sorter) {\n      // if not a string, return function or whatever it is\n      if (typeof sorter != 'string') {\n        return sorter;\n      }\n      // parse the sorter string\n      var args = trim(sorter).split(' ');\n      var query = args[0];\n      // check if query looks like [an-attribute]\n      var attrMatch = query.match(/^\\[(.+)\\]$/);\n      var attr = attrMatch && attrMatch[1];\n      var getValue = getValueGetter(attr, query);\n      // use second argument as a parser\n      var parser = Isotope.sortDataParsers[args[1]];\n      // parse the value, if there was a parser\n      sorter = parser ? function (elem) {\n        return elem && parser(getValue(elem));\n      } :\n      // otherwise just return value\n      function (elem) {\n        return elem && getValue(elem);\n      };\n      return sorter;\n    }\n\n    // get an attribute getter, or get text of the querySelector\n    function getValueGetter(attr, query) {\n      // if query looks like [foo-bar], get attribute\n      if (attr) {\n        return function getAttribute(elem) {\n          return elem.getAttribute(attr);\n        };\n      }\n\n      // otherwise, assume its a querySelector, and get its text\n      return function getChildText(elem) {\n        var child = elem.querySelector(query);\n        return child && child.textContent;\n      };\n    }\n    return mungeSorter;\n  }();\n\n  // parsers used in getSortData shortcut strings\n  Isotope.sortDataParsers = {\n    'parseInt': function (val) {\n      return parseInt(val, 10);\n    },\n    'parseFloat': function (val) {\n      return parseFloat(val);\n    }\n  };\n\n  // ----- sort method ----- //\n\n  // sort filteredItem order\n  proto._sort = function () {\n    if (!this.options.sortBy) {\n      return;\n    }\n    // keep track of sortBy History\n    var sortBys = utils.makeArray(this.options.sortBy);\n    if (!this._getIsSameSortBy(sortBys)) {\n      // concat all sortBy and sortHistory, add to front, oldest goes in last\n      this.sortHistory = sortBys.concat(this.sortHistory);\n    }\n    // sort magic\n    var itemSorter = getItemSorter(this.sortHistory, this.options.sortAscending);\n    this.filteredItems.sort(itemSorter);\n  };\n\n  // check if sortBys is same as start of sortHistory\n  proto._getIsSameSortBy = function (sortBys) {\n    for (var i = 0; i < sortBys.length; i++) {\n      if (sortBys[i] != this.sortHistory[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  // returns a function used for sorting\n  function getItemSorter(sortBys, sortAsc) {\n    return function sorter(itemA, itemB) {\n      // cycle through all sortKeys\n      for (var i = 0; i < sortBys.length; i++) {\n        var sortBy = sortBys[i];\n        var a = itemA.sortData[sortBy];\n        var b = itemB.sortData[sortBy];\n        if (a > b || a < b) {\n          // if sortAsc is an object, use the value given the sortBy key\n          var isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;\n          var direction = isAscending ? 1 : -1;\n          return (a > b ? 1 : -1) * direction;\n        }\n      }\n      return 0;\n    };\n  }\n\n  // -------------------------- methods -------------------------- //\n\n  // get layout mode\n  proto._mode = function () {\n    var layoutMode = this.options.layoutMode;\n    var mode = this.modes[layoutMode];\n    if (!mode) {\n      // TODO console.error\n      throw new Error('No layout mode: ' + layoutMode);\n    }\n    // HACK sync mode's options\n    // any options set after init for layout mode need to be synced\n    mode.options = this.options[layoutMode];\n    return mode;\n  };\n  proto._resetLayout = function () {\n    // trigger original reset layout\n    Outlayer.prototype._resetLayout.call(this);\n    this._mode()._resetLayout();\n  };\n  proto._getItemLayoutPosition = function (item) {\n    return this._mode()._getItemLayoutPosition(item);\n  };\n  proto._manageStamp = function (stamp) {\n    this._mode()._manageStamp(stamp);\n  };\n  proto._getContainerSize = function () {\n    return this._mode()._getContainerSize();\n  };\n  proto.needsResizeLayout = function () {\n    return this._mode().needsResizeLayout();\n  };\n\n  // -------------------------- adding & removing -------------------------- //\n\n  // HEADS UP overwrites default Outlayer appended\n  proto.appended = function (elems) {\n    var items = this.addItems(elems);\n    if (!items.length) {\n      return;\n    }\n    // filter, layout, reveal new items\n    var filteredItems = this._filterRevealAdded(items);\n    // add to filteredItems\n    this.filteredItems = this.filteredItems.concat(filteredItems);\n  };\n\n  // HEADS UP overwrites default Outlayer prepended\n  proto.prepended = function (elems) {\n    var items = this._itemize(elems);\n    if (!items.length) {\n      return;\n    }\n    // start new layout\n    this._resetLayout();\n    this._manageStamps();\n    // filter, layout, reveal new items\n    var filteredItems = this._filterRevealAdded(items);\n    // layout previous items\n    this.layoutItems(this.filteredItems);\n    // add to items and filteredItems\n    this.filteredItems = filteredItems.concat(this.filteredItems);\n    this.items = items.concat(this.items);\n  };\n  proto._filterRevealAdded = function (items) {\n    var filtered = this._filter(items);\n    this.hide(filtered.needHide);\n    // reveal all new items\n    this.reveal(filtered.matches);\n    // layout new items, no transition\n    this.layoutItems(filtered.matches, true);\n    return filtered.matches;\n  };\n\n  /**\n   * Filter, sort, and layout newly-appended item elements\n   * @param {Array or NodeList or Element} elems\n   */\n  proto.insert = function (elems) {\n    var items = this.addItems(elems);\n    if (!items.length) {\n      return;\n    }\n    // append item elements\n    var i, item;\n    var len = items.length;\n    for (i = 0; i < len; i++) {\n      item = items[i];\n      this.element.appendChild(item.element);\n    }\n    // filter new stuff\n    var filteredInsertItems = this._filter(items).matches;\n    // set flag\n    for (i = 0; i < len; i++) {\n      items[i].isLayoutInstant = true;\n    }\n    this.arrange();\n    // reset flag\n    for (i = 0; i < len; i++) {\n      delete items[i].isLayoutInstant;\n    }\n    this.reveal(filteredInsertItems);\n  };\n  var _remove = proto.remove;\n  proto.remove = function (elems) {\n    elems = utils.makeArray(elems);\n    var removeItems = this.getItems(elems);\n    // do regular thing\n    _remove.call(this, elems);\n    // bail if no items to remove\n    var len = removeItems && removeItems.length;\n    // remove elems from filteredItems\n    for (var i = 0; len && i < len; i++) {\n      var item = removeItems[i];\n      // remove item from collection\n      utils.removeFrom(this.filteredItems, item);\n    }\n  };\n  proto.shuffle = function () {\n    // update random sortData\n    for (var i = 0; i < this.items.length; i++) {\n      var item = this.items[i];\n      item.sortData.random = Math.random();\n    }\n    this.options.sortBy = 'random';\n    this._sort();\n    this._layout();\n  };\n\n  /**\n   * trigger fn without transition\n   * kind of hacky to have this in the first place\n   * @param {Function} fn\n   * @param {Array} args\n   * @returns ret\n   * @private\n   */\n  proto._noTransition = function (fn, args) {\n    // save transitionDuration before disabling\n    var transitionDuration = this.options.transitionDuration;\n    // disable transition\n    this.options.transitionDuration = 0;\n    // do it\n    var returnValue = fn.apply(this, args);\n    // re-enable transition for reveal\n    this.options.transitionDuration = transitionDuration;\n    return returnValue;\n  };\n\n  // ----- helper methods ----- //\n\n  /**\n   * getter method for getting filtered item elements\n   * @returns {Array} elems - collection of item elements\n   */\n  proto.getFilteredItemElements = function () {\n    return this.filteredItems.map(function (item) {\n      return item.element;\n    });\n  };\n\n  // -----  ----- //\n\n  return Isotope;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}